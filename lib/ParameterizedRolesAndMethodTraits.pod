package ParameterizedRolesAndMethodTraits;

use 5.008008;
our $VERSION = '0.01';

=head1 INTRODUCTION

You might already know I'm a big fan of L<MooseX::Declare>, which takes all the programming ease and power of L<Moose>, and adds a sweeter syntax which includes the most flexible method body signature system I've seen in any popular programming language.  For the uninitiated you can go from:

    package MooseClass;
    use Moose;

    sub my_method {
        my ($self, $name, $age) = @_;
        return "Hi $name, you are $age years old";
    }

    __PACKAGE__->meta->make_immutable;

To something like:

    use MooseX::Declare;
    class MooseXDeclareClass {
        method my_method(Str $name, Int $age) {
            return "Hi $name, you are $age years old";
        }
    }

This gives you a more modern class and method declaration syntax which lets you dispense with all the boilerplate validation and mucking around with "@_".  You get L<Moose> type constraint checking in method signatures for free, and hopefully this looks much more like what a modern programmer expects to see when creating classes.  The only downsides are a performance penalty and sometimes if you have syntax errors the error messages can be a little cryptic.  Both issues are a work in progress but if they really bother you you can always drop down to 'classic' Moose and use L<Method::Signatures::Simple> to get the shiny 'method' keyword (although you loose the method body signatures). 

Anyway, you may not know it, but L<MooseX::Declare> has some sweet syntax for declaring parameterized Roles (via L<MooseX::Role::Parameterized>) and Method Traits.  Both features are relatively undocumented, so here's the basic idea:

=head1 PARAMETERIZED ROLES

A Parameterized Role is a sort of Role generator.  This lets you make more generic roles by allowing you to specify role parameters at runtime.  These parameters can be used to inform and influence how a role works.  For example, L<MooseX::Role::BuildInstanceOf> makes it easier to aggregate functionality into a class by automatically generating accessors for a target instance.  However, the syntax for L<MooseX:::Role::Parameterized> is a bit verbose.  With L<MooseX::Declare> you can replace:

    package MyParameterizableRole;
    use MooseX::Role::Parameterized;

    parameter target_method => (
        isa => "Str",
        required => 1,
    );

    parameter  prefix => (
        isa => "Str",
        required => 1,
        default => "test",
    );

    role {
        my $p = shift @_;
        requires $p->target_method;
        around $p->target_method => sub {
            my ($orig, $self, $string) = @_;
            return $p->prefix .":". $self->$orig($string);
        };
    }
    
    1;

With:

    use MooseX::Declare;
    role MyParameterizableRole(
        Str :$target_method!,
        Str :$prefix! = "test"
    ) {
        requires $target_method;
        around "$target_method" (Str $string) {
            return $self->$orig("$prefix: $string");
        }
    }

This would create a role that decorates a method of choice with some additional text.  You might use it like:

    use MooseX::Declare;
    class MyDecoratedClass {
        method title(Str $string) {
            return "'$string' is the title";
        }
        with 'MyParameterizableRole' => {
            target_method => "title",
            prefix => "FAQ",
        };
    }

You'd get a class with a decorated method.  The only thing that might confuse you is how the 'with' is located after the method declaration.  I know you typically see the 'with' or 'extends' at the top of the class; this is possible since if you declare a method with 'sub' that get's parsed at compile time while the 'method' keyword is runtime.  This means that if the role you are aggregating requires a method, that method must be declared prior.  You'll need to remember this when using roles with MooseX::Declare.  I know this might seem strange at first but just remember the run-time versus compile-time thing and all will be well.

For more information be sure to see the documentation for L<MooseX::Role::Parameterized>.

=head1 METHOD TRAITS

In order to understand method traits, you need to remember that a method in Moose is represented internally by an instance of L<Moose::Meta::Method> (itself a subclass of L<Class::MOP::Method>) which mean that you can use roles to modify how a method works.  For example, you can add a role to a method that automatically adds logging when a method is called.  That's all that a method trait is, a role applied at runtime to a declared method.  It can take parameters, but unlike a parameterized role, the parameters are applied to the method instance attributes.  So a method trait is just a regular Moose role.  

For example, here's a role that wraps the return of a method in html your HTML tag of choice:

    use MooseX::Declare;
    role MyMethodTrait {
        has tag => (is=>'ro', isa=>'Str', required=>1, default=>'div');
        around wrap(ClassName $class: $code, %options) {
            my $method_obj;
            my $new_method = method(Str $string) {
                my $tag = $method_obj->tag;
                my $title = $self->$code($string);
                return "<$tag>$title</$tag>";
            };
            $method_obj = $class->$orig($new_method->actual_body, %options);
            return $method_obj;
        }
    }

Okay, so I'm not going to a lot of trouble to make sure the tag attributes is a valid HTML tag, but adding that bit would be easy with any number of CPAN modules.  You'd use the method trait like so:

    use MooseX::Declare;
    class MyParameterizedAndTrait {
        method title(Str $string)
        does MyMethodTrait(tag=>"p")
        {
            return "'$string' is the title";
        }
        with 'MyParameterizableRole' => {
            target_method => "title",
            prefix => "FAQ",
        };
    }

That 'does' (and its alias 'is') is similar to the way 'with' works on the class level, it applies the role at runtime to the instance representing the method.  Parameters basically get passed down at construction time.  So, if you constructed the above class and called the method 'title' like so, you get the following:

    my $obj = MyParameterizedAndTrait->new;
    say $obj->title("Hello World!");

    ## output is: "<p>'FAQ: Hello' is the title</p>"

=head1 CONCLUSION

MooseX::Declare is more than just a sweeter syntax for L<Moose>, it aggregates and simplifies use of some valuable techniques for building better Object Oriented code.  Both parameterized roles and method traits offer techniques for reusing behavior and logic that can be semantically more meaningful than alternatives.

For more info see:

    - All the code and text of the blog can be downloaded /forked /executed over on Github.  
    - Also see Rafl's blog on MooseX::Declare and Parameterized Roles

Have Fun!

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2010 by John Napiorkowski.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut

